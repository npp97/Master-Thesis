function V = MultiSpherePotential( r, sigma, srcpnts, dipmom, obspnts, maxdegree )
% MultiSpherePotential calculates the electric potential in M points 
% on the surface of a S-layered sphere due to N current dipoles located in
% the innermost layer, making use of the analytical formula given in:
% Zhang Z., "A Fast Method to Compute Surface Potentials Generated by 
% Dipoles Within Multilayer Anisotropic Spheres",Phys Med Biol 40(3)(1995), 
% pp. 335-49.
%
% Input arguments:
% r         =  Sx1 vector of spheres radii [m]
%              ([ r_inner ... ... r_outer ]).
% sigma     =  Sx1 vector of electric conductivities [S/m].
%              ([ sigma_inner ... ... sigma_outer ]).
% srcpnts   =  Nx3 matrix of source dipoles coordinates [m].
% dipmom    =  Nx3 matrix of dipole moments components [A*m]
%              (in the innermost layer).
% obspnts   =  Mx3 matrix of observation points coordinates [m]
%              (on sphere surface).
% maxdegree =  maximum degree of Legendre polynomials and associated
%              Legendre polynomials (to approximate infinity).
%
% Output:
% V        =  Mx1 vector of electric potential at observation points [V].
%-------------------------------------------------------------------------
% !!WARNING!!: the formula is singular for dipole at origin
%-------------------------------------------------------------------------
%
S = length(r); M = size(obspnts,1); N = size(srcpnts,1);
V = zeros(M,1);
for i = 1:M
    for j = 1:N
        P = dipmom(j,1)*dipmom(j,1) + ...
            dipmom(j,2)*dipmom(j,2) + ...
            dipmom(j,3)*dipmom(j,3);
        P = sqrt(P);
        r0 = srcpnts(j,1)*srcpnts(j,1) + ...
             srcpnts(j,2)*srcpnts(j,2) + ...
             srcpnts(j,3)*srcpnts(j,3);
        r0 = sqrt(r0);
        cosg = (srcpnts(j,:)*obspnts(i,:)') / r0 / r(S);
        cosa = (srcpnts(j,:)*dipmom(j,:)') / r0 / P;
        sina = acos(cosa); sina = sin(sina);
        if abs(cosg) == 1 || abs(sina) < eps % To avoid singularities
            cosb = 0;
        else
            P1 = [srcpnts(j,2)*dipmom(j,3) - srcpnts(j,3)*dipmom(j,2), ...
                  srcpnts(j,3)*dipmom(j,1) - srcpnts(j,1)*dipmom(j,3), ...
                  srcpnts(j,1)*dipmom(j,2) - srcpnts(j,2)*dipmom(j,1)];
            P2 = [srcpnts(j,2)*obspnts(i,3) - srcpnts(j,3)*obspnts(i,2), ...
                  srcpnts(j,3)*obspnts(i,1) - srcpnts(j,1)*obspnts(i,3), ...
                  srcpnts(j,1)*obspnts(i,2) - srcpnts(j,2)*obspnts(i,1)];
            lP1 = P1(1)*P1(1) + P1(2)*P1(2) + P1(3)*P1(3);
            lP1 = sqrt(lP1);
            lP2 = P2(1)*P2(1) + P2(2)*P2(2) + P2(3)*P2(3);
            lP2 = sqrt(lP2);
            cosb = -P1*P2' / lP1 / lP2;
        end
        [LP, ALP1] = LegPoly(cosg, maxdegree);
        A = 0;
        for n = 1:maxdegree
            m = [1 0; 0 1];
            if S > 1
                for k = (S-1):-1:1
                    rs = sigma(k)/sigma(k+1);
                    m11 = n+(n+1)*rs;
                    m12 = (n+1)*(rs-1)*(r(S)/r(k))^(2*n+1);
                    m21 = n*(rs-1)*(r(k)/r(S))^(2*n+1);
                    m22 = n+1+n*rs;
                    m = m*[m11 m12; m21 m22];
                end
            end
            m = m / (2*n+1)^(S-1);
            fn = n / (n*m(2,2)+(1+n)*m(2,1));
            A = A + (2*n+1)/n * (r0/r(S))^(n-1) * fn * ...
                    (n*cosa*LP(n) + cosb*sina*ALP1(n));
        end
        V(i) = V(i) + A * P;
    end
end
a = 1/(4*pi*sigma(S)*r(S)*r(S));
V = a*V;
end

function [LP, ALP1] = LegPoly(x,maxdegree)
% LEGPOLY calculates and stores the Legendre polynomial from the 1st to the 
% maxdegree-th order and the associated Legendre polynomial of 1st degree 
% from the 1st to the maxdegree-th order in x (scalar).
% The algorithm is based on the recursive formulas.
%
% Input:
% x          =   evaluation point;
% maxdegree  =   desired maximum order of polynomials.
%
% Output:
% LP         =   maxdegree x 1 vector of Legendre polynomial from the 1st  
%                to the maxdegree-th order evaluated in in x;
% ALP1       =   maxdegree x 1 vector of associated Legendre polynomial of 
%                1st degree from the 1st to the maxdegree-th order
%                evaluated in x.

LP = ones(maxdegree,1);
LP(1) = x*LP(1);

ALP1 = zeros(maxdegree,1);
ALP1(1) = -sqrt(1-x^2);

if maxdegree ~= 1
    LP(2)   = 0.5*(3*x^2-1); 
    ALP1(2) = 3*x*ALP1(1,:);
    for i = 3:maxdegree
        LP(i)   = (x*(2*i-1)*LP(i-1)-(i-1)*LP(i-2))/i;
        ALP1(i) = (x*(2*i-1)*ALP1(i-1)-i*ALP1(i-2))/(i-1);
    end
end
end

% THE FOLLOWING IS A STUB OF GENERALIZATION FOR x VECTOR OR MATRIX
%
% function [LP, ALP1] = LegPoly(x,maxdegree)
% 
% LP = ones(maxdegree, size(x,1));
% LP(1,:) = x.*LP(1,:);
% 
% ALP1 = zeros(maxdegree, size(x,1));
% ALP1(1,:) = -sqrt(1-x.^2);
% 
% 
% if maxdegree ~= 1
%     LP(2,:) = 0.5*(3*x.^2-1); 
%     ALP1(2,:) = 3*x.*ALP1(1,:);
%     for i = 3 : maxdegree
%         LP(i,:) = (x .* (2 * i - 1).*LP(i-1,:) - (i - 1).*LP(i-2,:))/i;
%         ALP1(i,:) = (x .* (2 * i - 1).*ALP1(i-1,:) - i*ALP1(i-2,:))/(i-1);
%     end
% end
% end

% THE FOLLOWING FUNCTION DOESN'T STORE THE VALUES OF POLYNOMIALS OF DEGREE
% LESS THAN n.
%
% function [LP, ALP1] = LegPoly(x,i)
% 
% LP = ones(size(x,1));
% temp = x.*LP;
% 
% ALP1 = zeros(size(x,1));
% tempA = -sqrt(1-x.^2);
% 
% if i==1
%     LP = temp;
%     ALP1 = tempA;
% else
%     for i = 2 : i
%         temp1 = (x .* (2 * i - 1).*temp - (i - 1)*LP)/i;
%         LP = temp;
%         temp = temp1;
%         
%         tempA1 = (x .* (2 * i - 1).*tempA - i*ALP1)/(i-1);
%         ALP1 = tempA;
%         tempA = tempA1;
%     end
%     LP = temp1;
%     ALP1 = tempA1;
% end
% end